(1) jsp的静态包含和动态包含的区别：
一、执行时间上：        
静态<%@  include file=”relativeURI”%>在编译阶段执行，
也就是将relativeURI的JSP源码复制到目标文件内，置于JSP容器中，
编译成一个servlet文件。
动态<jsp:include page=””>在请求处理阶段执行，即被包含和目标jsp文件分别
编译成servlet，然后目表由编译好的servlet回应请求。
二、引入的内容不同：  前者引入静态的html或jsp文本，效果和复制文本成一个jsp一样。
后者引入执行页面或者servlet所生成的应答文本。
(２)Java中的GC是什么? 为什么要有GC
java 垃圾回收器.　Java有了GC，就不需要程序员去人工释放内存空间。
当Java虚拟机发觉内存资源紧张的时候，就会自动地去清理无用变量所占用的内存空间。
(３)EJB包括（SessionBean,EntityBean）说出他们的生命周期，及如何管理事务的?
SessionBean：Stateless Session Bean（无状态） 的生命周期是由容器决定的，

当客户机发出请求要建立一个Bean的实例时，EJB容器不一定要创建一个新的Bean的实例供客户机调用，
而是随便找一个现有的实例提供给客户机。当客户机第一次调用一个Stateful(有状态) Session Bean 时，
容器必须立即在服务器中创建一个新的Bean实例，并关联到客户机上，
以后此客户机调用Stateful Session Bean 的方法时容器会把调用分派到与此客户机相关联的Bean实例。
EntityBean：Entity Beans能存活相对较长的时间，并且状态是持续的。只要数据库中的数据存在，
Entity beans就一直存活。而不是按照应用程序或者服务进程来说的。即使EJB容器崩溃了，
Entity beans也是存活的。Entity Beans生命周期能够被容器或者 Beans自己管理。
EJB通过以下技术管理实务：对象管理组织（OMG）的对象实务服务（OTS）
，Sun Microsystems的Transaction Service（JTS）、
Java Transaction API（JTA），开发组（X/Open）的XA接口。
(４)
数据库连接池在初始化时将创建一定数量的数据库连接放到连接池中，这些数据库连接的数量是由最小数据库连接数来设定的。
无论这些数据库连接是否被使用，连接池都将一直保证至少拥有这么多的连接数量。
连接池的最大数据库连接数量限定了这个连接池能占有的最大连接数，
当应用程序向连接池请求的连接数超过最大连接数量时，这些请求将被加入到等待队列中。
数据库连接池的最小连接数和最大连接数的设置要考虑到下列几个因素：
  1) 最小连接数是连接池一直保持的数据库连接，所以如果应用程序对数据库连接的使用量不大，
将会有大量的数据库连接资源被浪费；
  2) 最大连接数是连接池能申请的最大连接数，如果数据库连接请求超过此数，后面的数据库连接请求将被加入到等待队列中，
这会影响之后的数据库操作。
  3) 如果最小连接数与最大连接数相差太大，那么最先的连接请求将会获利，
之后超过最小连接数量的连接请求等价于建立一个新的数据库连接。
不过，这些大于最小连接数的数据库连接在使用完不会马上被释放，它将被放到连接池中等待重复使用或是空闲超时后被释放

